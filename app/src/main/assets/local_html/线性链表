<!DOCTYPE html>
<html>
<head>
    <title>排序技术</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">
    body{
        font-family: '楷体'
    }
p{
    text-indent: 20px;
    font-family: '楷体'
}

</style>
</head>
<body style="background:#CDB38B; ">
<p>
    <br/>
</p>
<p>
    <strong>1.5 线性链表</strong>
</p>
<p>
    1.5.1 线性链表的基本概念
</p>
<p>
    线性表的顺序存储结构具有简单、运算方便等优点，特别是对于小线性表或长度固定的线性表，采用顺序存储结构的优越性就更为突出。
</p>
<p>
    &nbsp; &nbsp; 但是，线性表的顺序存储结构在数据量大、运算量大时，就显得很不方便，且运算效率也较低。实际上，线性表的顺序存储结构存在以下几个方面的缺点：
</p>
<p>
    &nbsp; &nbsp; ●在一般情况下，要在顺序存储的线性表中插入一个新元素或删除一个元素时，为了保证插入或删除后的线性表仍然为顺序存储，则在插入或删除的过程中需要移动大量的数据元素。
</p>
<p>
    &nbsp; &nbsp; ●当为一个线性表分配顺序存储空间后，如果线性表的存储空间已满，但还需要插入新元素时，就会发生“上溢”错误。
</p>
<p>
    &nbsp; &nbsp; ●线性表的顺序存储结构不便于对存储空间的动态分配。
</p>
<p>
    &nbsp; &nbsp; &nbsp;由于线性表的顺序存储结构存在以上缺点，因此，对于大的线性表，特别是元素变动频繁的大线性表不宜采用顺序存储结构，此时，就要用到链式存储结构。
</p>
<p>
    1.线性链表
</p>
<p>
    &nbsp; &nbsp; 所谓线性链表，就是指线性表的链式存储结构，简称链表。由于这种链表中每个结点只有一个指针域，故称为单链表。
</p>
<p>
    &nbsp; &nbsp; 线性表链式存储结构的特点是用一组不连续的存储单元存储线性表中的各个元素。因为存储单元不连续，数据元素之间的逻辑关系，就不能依靠数据元素存储单元之间的物理关系来表示。为了适应这种存储结构，计算机存储空间被划分为一个个小块，每个小块占若干自己，通常称这些小块为存储结点。
</p>
<p>
    &nbsp; &nbsp; 为了存储线性表中的每一个元素，一方面要存储数据元素的值，另一方面要存储各数据元素之间的前后件关系。为此，将存储空间中的每一个存储结点分为两部分：一部分用于存储数据元素的值，称为数据域；另一部分用于存放下一个数据元素的存储序号（即存储结点的地址），即指向后件结点，称为指针域，如图1-12所示。因为增加了指针域，所以存储相同的非空线性表，链表用的空间要多于顺序表用的存储空间。链式存储结构既可以表示线性结构，也可以表示非线性结构。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
   
          图 &nbsp; 图1-12 线性链表的存储&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T1-12.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    在线性链表中，第一个元素没有前件，指向链表中的第一个结点的指针，是一个特殊的指针，称为这个链表的头指针(HEAD)。最后一个元素没有后件，因此，线性链表最后一个结点的指针域为空，用NULL或0表示。
</p>
<p>
    例如，设线性表（A，B，C，D，E，F）在存储空间中的存储情况如图1-13所示，头指针HEAD中存放的是第一个元素A的存储地址（即存储序号）。为了直观地表示该线性链表中各元素之间的前后件关系，还可以用图1-14所示的逻辑状态来表示，其中每一个结点上面的数字表示该结点的存储序号（即结点号）。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
   

         图1-13 线性表的物理状态
    <img src="file:///android_asset/local_html/local_imgs/T1-13.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    

        图1-14 线性表的逻辑状态&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T1-14.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 线性表的存储单元是任意的，即各数据结点的存储序号可以是连续的，也可以是不连续的，而各结点在存储空间中的位置关系与逻辑关系也不一致，前后关系由存储结点的指针来表示。指向第一个数据元素的头指针HEAD等于NULL或者0时，称为空表。
</p>
<p>
    &nbsp; &nbsp; 前面讨论的是线性单链表。在实际应用中，有时还会用到每个存储结点有两个指针域的链表，一个指针域存放前件的地址，称为左指针（Llink），一个指针域存放后件的地址，称为右指针（Rlink）。这样的线性链表称为双向链表。图1-15是双向链表的示意图。双向链表的第一个元素的左指针（Llink）为空，最后一个元素的右指针（Rlink）为空。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    
        图1-15 双向链表示意图&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T1-15.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; &nbsp;在单链表中，只能顺指针向链尾方向进行扫描，由某一个结点出发，只能找到它的后件，若要找出它的前件，必须从头指针开始重新寻找。而在双向链表中，由于为每个结点设置了两个指针，从某一个结点出发，可以很方便地找到其他任意一个结点。&nbsp;
</p>
<p>
    2.带链的栈
</p>
<p>
    &nbsp; &nbsp; 栈也可以采用链式存储结构表示，把栈组织成一个单链表。这种数据结构可称为带链的栈。图1-16（a）是带链的栈示意图。
</p>
<p>
    3.带链的队列
</p>
<p>
    &nbsp; &nbsp; &nbsp;与栈类似，队列也可以采用链式存储结构表示。带链的队列就是用一个单链表来表示队列，队列中的每一个元素对应链表中的一个结点。图1-16（b）是带链的队列的示意图。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
   
       图1-16 带链的栈和带链的队列&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T1-16.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    4.顺序表和链表的比较
</p>
<p>
    &nbsp; &nbsp; 线性表的顺序存储方式，称为顺序表。线性表的链式存储结构，称为线性链表，简称链表。两者的优缺点如表1-5所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
      表1-5 顺序表和链表的优缺点比较
    <img src="file:///android_asset/local_html/local_imgs/B1-5.jpg" style="width:100%;border-radius: 10px;">
    
</p>
<p>
    &nbsp;
</p>
<p>
    <br/>
</p>
<p>
    1.5.2 线性链表的基本运算
</p>
<p>
    对线性链表进行的运算主要包括查找、插入、删除、合并、分解、逆转、复制和排序。其中，查找、插入和删除运算是考查的重点。
</p>
<p>
    1.在线性链表中查找指定元素
</p>
<p>
    &nbsp; &nbsp; 查找指定元素所处的位置是插入和删除等操作的前提，只有先通过查找定位才能进行元素的插入和删除等进一步的运算。
</p>
<p>
    &nbsp; &nbsp; 在线性链表中查找指定元素必须从队头指针出发，沿着指针域中的Next指针逐个结点搜索，直到找到指定元素或链表尾部为止，而不能像顺序表那样只要知道了首地址，就可以计算出任意元素的存储地址。因此，线性链表不是随机存储结构。
</p>
<p>
    &nbsp; &nbsp; &nbsp;在链表中，扫描到等于指定元素值的结点时，返回该结点的位置，如果链表中没有元素的值等于指定元素，则扫描完所有元素返回空。
</p>
<p>
    2.线性链表的插入
</p>
<p>
    &nbsp; &nbsp; &nbsp;线性链表的插入是指在链式存储结构下的线性表中插入一个新元素。在插入一个新元素之前，首先要给该元素分配一个新结点，以便用于存储该元素的值，然后将存放新元素值的结点链接到线性链表中指定的位置。新结点可以从可利用栈中取得，如图1-17所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    

  &nbsp;图1-17 取空闲结点&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T1-17.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 要在线性链表中数据域为M的结点之前插入一个新元素n，则插入过程如下所述：
</p>
<p>
    &nbsp; （1）取可利用栈的栈顶空闲结点，生成一个数据域为n的结点，将新结点的存储序号存放在指针变量p中。
</p>
<p>
    &nbsp; （2）在线性链表中查找数据域为M的结点，将其前件的存储序号存放在变量q中。
</p>
<p>
    &nbsp; （3）将新结点p的指针域内容设置为指向数据域为M的结点。
</p>
<p>
    &nbsp; （4）将结点q的指针域内容改为指向新结点p。
</p>
<p>
    &nbsp; &nbsp;插入过程图1-18所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
   
   &nbsp; 图1-18 线性链表的插入&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T1-18.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 由于线性链表执行插入运算时，新结点的存储单元取自可利用栈。因此，只要可利用栈非空，线性链表总能找到存储插入元素的新结点，因而不需规定最大存储空间，也不会发生“上溢”的错误。此外，线性链表在执行插入运算时，不需要移动数据元素，只需要改动有关结点的指针域即可，插入运算效率大大提高。
</p>
<p>
    3.线性链表的删除
</p>
<p>
    &nbsp; &nbsp; &nbsp;线性链表的删除是指在链式存储结构下的线性表中删除包含指定元素的结点。
</p>
<p>
    &nbsp; &nbsp; &nbsp;在线性链表中删除数据域为M的结点，其过程如下所述。
</p>
<p>
    &nbsp; （1）在线性链表中查找包含元素M的结点，将该结点的存储序号存放在p中。
</p>
<p>
    &nbsp; （2）把p结点的前件存储序号存放在变量q中，将q结点的指针修改为指向p结点的指针所指向的结点（即p结点的后件）。
</p>
<p>
    &nbsp; （3）把数据域为M的结点“回收”到可利用栈。
</p>
<p>
    &nbsp; &nbsp; 删除过程如图1-19所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    &nbsp;
</p>
<p>
    <br/>
</p>
<p>
    
    图1-19 线性链表的删除&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T1-19.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 说明：和插入运算一样，线性链表的删除运算也不需要移动元素。删除运算只需改变被删除元素前件的指针域即可。而且，删除的结点回收到可利用栈中，可供线性链表插入运算时使用。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    1.5.3 循环链表及其基本运算
</p>
<p>
    1.循环链表的定义
</p>
<p>
    &nbsp; &nbsp; 在单链表的第一个结点前增加一个表头结点，队头指针指向表头结点，最后一个结点的指针域的值由NULL改为指向表头结点，这样的链表称为循环链表。循环链表中，所有结点的指针构成了一个环状链。循环链表的逻辑状态如图1-20所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
   &nbsp; &nbsp;图1-20 循环链表的逻辑状态&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T1-20.jpg" style="width:100%;border-radius: 10px;">
    
</p>
<p>
    <br/>
</p>
<p>
    2.循环链表与单链表的比较
</p>
<p>
    &nbsp; &nbsp; 对单链表的访问是一种顺序访问，即从其中某一个结点出发，只能找到它的直接后继（即后件），但无法找到它的直接前驱（即前件），而且对于空表和第一个结点的处理必须单独考虑，空表与非空表的运算不统一。
</p>
<p>
    &nbsp; &nbsp; 在循环链表中，只要得到表中任一结点的位置，就可以从它出发访问到全表所有的结点。另外，由于在循环链表中设置了一个表头结点，因此，在任何情况下循环链表中至少有一个结点存在，从而使空表与非空表的运算统一。
</p>
<p>
    &nbsp; &nbsp; 循环链表的插入和删除的方法与线性单链表基本相同。&nbsp;
</p>
<p>
    <br/>
</p>
</body></html>